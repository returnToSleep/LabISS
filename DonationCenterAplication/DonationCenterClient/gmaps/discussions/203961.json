[
  {
    "Id": "414627",
    "ThreadId": "203961",
    "Html": "<p>Hi,</p>\r\n<p>How can I do direction marker in GMap.net?</p>\r\n<p>Thanks.</p>\r\n<p>Ramazan ULUCAY</p>",
    "PostedDate": "2010-03-05T07:51:53.073-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "414658",
    "ThreadId": "203961",
    "Html": "<p>direction, you mean circle with arrow on renderTransform at some angle?</p>",
    "PostedDate": "2010-03-05T08:40:03.157-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "414925",
    "ThreadId": "203961",
    "Html": "<p>Yes. I want to show the directions with angle for arrow.&nbsp;</p>",
    "PostedDate": "2010-03-06T01:56:54.183-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "414973",
    "ThreadId": "203961",
    "Html": "<p>try this:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">using</span> System;\r\n<span style=\"color:Blue\">using</span> System.Linq;\r\n<span style=\"color:Blue\">using</span> System.Windows;\r\n<span style=\"color:Blue\">using</span> System.Windows.Controls;\r\n<span style=\"color:Blue\">using</span> System.Windows.Controls.Primitives;\r\n<span style=\"color:Blue\">using</span> System.Windows.Input;\r\n<span style=\"color:Blue\">using</span> System.Windows.Media;\r\n<span style=\"color:Blue\">using</span> System.Windows.Media.Animation;\r\n<span style=\"color:Blue\">using</span> System.Windows.Media.Effects;\r\n<span style=\"color:Blue\">using</span> System.Windows.Shapes;\r\n<span style=\"color:Blue\">using</span> GMap.NET.WindowsPresentation;\r\n<span style=\"color:Blue\">using</span> Trolis.Entities;\r\n<span style=\"color:Blue\">using</span> Trolis.LinqToSql;\r\n<span style=\"color:Blue\">using</span> System.Diagnostics;\r\n<span style=\"color:Blue\">using</span> System.Globalization;\r\n\r\n<span style=\"color:Blue\">namespace</span> Trolis.Markers\r\n{\r\n   <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> DrawingVisualFx : DrawingVisual\r\n   {\r\n      <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">static</span> <span style=\"color:Blue\">readonly</span> DependencyProperty EffectProperty = DependencyProperty.Register(<span style=\"color:#A31515\">&quot;Effect&quot;</span>, <span style=\"color:Blue\">typeof</span>(Effect), <span style=\"color:Blue\">typeof</span>(DrawingVisualFx),\r\n                                      <span style=\"color:Blue\">new</span> FrameworkPropertyMetadata(<span style=\"color:Blue\">null</span>, (FrameworkPropertyMetadataOptions.AffectsRender), <span style=\"color:Blue\">new</span> PropertyChangedCallback(OnEffectChanged)));\r\n      <span style=\"color:Blue\">public</span> Effect Effect\r\n      {\r\n         <span style=\"color:Blue\">get</span>\r\n         {\r\n            <span style=\"color:Blue\">return</span> (Effect) GetValue(EffectProperty);\r\n         }\r\n         <span style=\"color:Blue\">set</span>\r\n         {\r\n            SetValue(EffectProperty, value);\r\n         }\r\n      }\r\n\r\n      <span style=\"color:Blue\">private</span> <span style=\"color:Blue\">static</span> <span style=\"color:Blue\">void</span> OnEffectChanged(DependencyObject o, DependencyPropertyChangedEventArgs e)\r\n      {\r\n         DrawingVisualFx drawingVisualFx = o <span style=\"color:Blue\">as</span> DrawingVisualFx;\r\n         <span style=\"color:Blue\">if</span>(drawingVisualFx != <span style=\"color:Blue\">null</span>)\r\n         {\r\n            drawingVisualFx.setMyProtectedVisualEffect((Effect) e.NewValue);\r\n         }\r\n      }\r\n\r\n      <span style=\"color:Blue\">private</span> <span style=\"color:Blue\">void</span> setMyProtectedVisualEffect(Effect effect)\r\n      {\r\n         VisualEffect = effect;\r\n      }\r\n   }\r\n\r\n   <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> CircleVisual : FrameworkElement\r\n   {\r\n      Popup Popup = <span style=\"color:Blue\">new</span> Popup();\r\n      <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">readonly</span> Controls.TrolleyTooltip Tooltip = <span style=\"color:Blue\">new</span> Trolis.Controls.TrolleyTooltip();\r\n      <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">readonly</span> TrolleyMarker Marker;\r\n\r\n      <span style=\"color:Blue\">public</span> CircleVisual(TrolleyMarker m)\r\n      {\r\n         Marker = m;\r\n         Popup.AllowsTransparency = <span style=\"color:Blue\">true</span>;\r\n         Popup.PlacementTarget = <span style=\"color:Blue\">this</span>;\r\n         Popup.Placement = PlacementMode.Mouse;\r\n         Popup.Child = Tooltip;\r\n         Popup.Child.Opacity = 0.777;\r\n\r\n         Marker.ZIndex = 100;\r\n\r\n         SizeChanged += <span style=\"color:Blue\">new</span> SizeChangedEventHandler(CircleVisual_SizeChanged);\r\n         MouseEnter += <span style=\"color:Blue\">new</span> System.Windows.Input.MouseEventHandler(CircleVisual_MouseEnter);\r\n         MouseLeave += <span style=\"color:Blue\">new</span> System.Windows.Input.MouseEventHandler(CircleVisual_MouseLeave);\r\n         MouseUp += <span style=\"color:Blue\">new</span> MouseButtonEventHandler(CircleVisual_MouseUp);\r\n         Loaded += <span style=\"color:Blue\">new</span> RoutedEventHandler(OnLoaded);\r\n\r\n         Text = <span style=\"color:#A31515\">&quot;?&quot;</span>;\r\n\r\n         StrokeArrow.EndLineCap = PenLineCap.Triangle;\r\n         StrokeArrow.LineJoin = PenLineJoin.Round;\r\n\r\n         RenderTransform = scale;\r\n\r\n         Width = Height = 22;\r\n         FontSize = (Width/1.55);\r\n         Stroke.Thickness = Width/22;\r\n      }\r\n\r\n      <span style=\"color:Blue\">void</span> CircleVisual_MouseUp(<span style=\"color:Blue\">object</span> sender, MouseButtonEventArgs e)\r\n      {\r\n         <span style=\"color:Blue\">var</span> vh = <span style=\"color:Blue\">this</span>.Marker.Data;\r\n         <span style=\"color:Blue\">if</span>(vh != <span style=\"color:Blue\">null</span> &amp;&amp; MainWindow.Instance.Company == Company.Trolley)\r\n         {\r\n            MainWindow.Instance.SetCurrentTrolleyMarker(vh);\r\n         }\r\n      }\r\n\r\n      <span style=\"color:Blue\">void</span> CircleVisual_SizeChanged(<span style=\"color:Blue\">object</span> sender, SizeChangedEventArgs e)\r\n      {\r\n         Marker.Offset = <span style=\"color:Blue\">new</span> System.Windows.Point(-e.NewSize.Width/2, -e.NewSize.Height/2);\r\n         scale.CenterX = -Marker.Offset.X;\r\n         scale.CenterY = -Marker.Offset.Y;\r\n      }\r\n\r\n      <span style=\"color:Blue\">void</span> OnLoaded(<span style=\"color:Blue\">object</span> sender, RoutedEventArgs e)\r\n      {\r\n         UpdateVisual(<span style=\"color:Blue\">true</span>);\r\n      }\r\n\r\n      ScaleTransform scale = <span style=\"color:Blue\">new</span> ScaleTransform(1, 1);\r\n\r\n      <span style=\"color:Blue\">void</span> CircleVisual_MouseLeave(<span style=\"color:Blue\">object</span> sender, System.Windows.Input.MouseEventArgs e)\r\n      {\r\n         Stroke.Thickness -= 2;\r\n         <span style=\"color:Blue\">if</span>(Popup.IsOpen)\r\n         {\r\n            Popup.IsOpen = <span style=\"color:Blue\">false</span>;\r\n         }\r\n\r\n         Marker.ZIndex -= 10000;\r\n         Cursor = Cursors.Arrow;\r\n\r\n         <span style=\"color:Blue\">this</span>.Effect = <span style=\"color:Blue\">null</span>;\r\n\r\n         scale.ScaleY = 1;\r\n         scale.ScaleX = 1;\r\n      }\r\n\r\n      <span style=\"color:Blue\">void</span> CircleVisual_MouseEnter(<span style=\"color:Blue\">object</span> sender, System.Windows.Input.MouseEventArgs e)\r\n      {\r\n         Stroke.Thickness += 2;\r\n         <span style=\"color:Blue\">if</span>(!Popup.IsOpen)\r\n         {\r\n            Popup.IsOpen = <span style=\"color:Blue\">true</span>;\r\n         }\r\n\r\n         Marker.ZIndex += 10000;\r\n         Cursor = Cursors.Hand;\r\n\r\n         <span style=\"color:Blue\">this</span>.Effect = ShadowEffect;\r\n\r\n         scale.ScaleY = 1.5;\r\n         scale.ScaleX = 1.5;\r\n      }\r\n\r\n      <span style=\"color:Blue\">public</span> DropShadowEffect ShadowEffect;\r\n\r\n      <span style=\"color:Blue\">static</span> Typeface Font = <span style=\"color:Blue\">new</span> Typeface(<span style=\"color:Blue\">new</span> FontFamily(<span style=\"color:#A31515\">&quot;Arial&quot;</span>), FontStyles.Normal, FontWeights.Bold, FontStretches.Normal);\r\n      FormattedText FText;\r\n\r\n      <span style=\"color:Blue\">private</span> Brush background = Brushes.Blue;\r\n      <span style=\"color:Blue\">public</span> Brush Background\r\n      {\r\n         <span style=\"color:Blue\">get</span>\r\n         {\r\n            <span style=\"color:Blue\">return</span> background;\r\n         }\r\n         <span style=\"color:Blue\">set</span>\r\n         {\r\n            <span style=\"color:Blue\">if</span>(background != value)\r\n            {\r\n               background = value;\r\n               IsChanged = <span style=\"color:Blue\">true</span>;\r\n            }\r\n         }\r\n      }\r\n\r\n      <span style=\"color:Blue\">private</span> Brush foreground = Brushes.White;\r\n      <span style=\"color:Blue\">public</span> Brush Foreground\r\n      {\r\n         <span style=\"color:Blue\">get</span>\r\n         {\r\n            <span style=\"color:Blue\">return</span> foreground;\r\n         }\r\n         <span style=\"color:Blue\">set</span>\r\n         {\r\n            <span style=\"color:Blue\">if</span>(foreground != value)\r\n            {\r\n               foreground = value;\r\n               IsChanged = <span style=\"color:Blue\">true</span>;\r\n\r\n               ForceUpdateText();\r\n            }\r\n         }\r\n      }\r\n\r\n      <span style=\"color:Blue\">private</span> Pen stroke = <span style=\"color:Blue\">new</span> Pen(Brushes.Blue, 10.0);\r\n      <span style=\"color:Blue\">public</span> Pen Stroke\r\n      {\r\n         <span style=\"color:Blue\">get</span>\r\n         {\r\n            <span style=\"color:Blue\">return</span> stroke;\r\n         }\r\n         <span style=\"color:Blue\">set</span>\r\n         {\r\n            <span style=\"color:Blue\">if</span>(stroke != value)\r\n            {\r\n               stroke = value;\r\n               IsChanged = <span style=\"color:Blue\">true</span>;\r\n            }\r\n         }\r\n      }\r\n\r\n      <span style=\"color:Blue\">private</span> Pen strokeArrow = <span style=\"color:Blue\">new</span> Pen(Brushes.Blue, 2.0);\r\n      <span style=\"color:Blue\">public</span> Pen StrokeArrow\r\n      {\r\n         <span style=\"color:Blue\">get</span>\r\n         {\r\n            <span style=\"color:Blue\">return</span> strokeArrow;\r\n         }\r\n         <span style=\"color:Blue\">set</span>\r\n         {\r\n            <span style=\"color:Blue\">if</span>(strokeArrow != value)\r\n            {\r\n               strokeArrow = value;\r\n               IsChanged = <span style=\"color:Blue\">true</span>;\r\n            }\r\n         }\r\n      }\r\n\r\n      <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">double</span> FontSize = 16;\r\n\r\n      <span style=\"color:Blue\">private</span> <span style=\"color:Blue\">double</span>? angle = 0;\r\n      <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">double</span>? Angle\r\n      {\r\n         <span style=\"color:Blue\">get</span>\r\n         {\r\n            <span style=\"color:Blue\">return</span> angle;\r\n         }\r\n         <span style=\"color:Blue\">set</span>\r\n         {\r\n            <span style=\"color:Blue\">if</span>(!Angle.HasValue || !value.HasValue || (Angle.HasValue &amp;&amp; value.HasValue &amp;&amp; Math.Abs(angle.Value - value.Value) &gt; 11))\r\n            {\r\n               angle = value;\r\n               IsChanged = <span style=\"color:Blue\">true</span>;\r\n            }\r\n         }\r\n      }\r\n      <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">bool</span> IsChanged = <span style=\"color:Blue\">true</span>;\r\n\r\n      <span style=\"color:Blue\">void</span> ForceUpdateText()\r\n      {\r\n         FText = <span style=\"color:Blue\">new</span> FormattedText(text, CultureInfo.InvariantCulture, FlowDirection.LeftToRight, Font, FontSize, Foreground);\r\n         IsChanged = <span style=\"color:Blue\">true</span>;\r\n      }\r\n\r\n      <span style=\"color:Blue\">string</span> text;\r\n      <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">string</span> Text\r\n      {\r\n         <span style=\"color:Blue\">get</span>\r\n         {\r\n            <span style=\"color:Blue\">return</span> text;\r\n         }\r\n         <span style=\"color:Blue\">set</span>\r\n         {\r\n            <span style=\"color:Blue\">if</span>(text != value)\r\n            {\r\n               text = value;\r\n               ForceUpdateText();\r\n            }\r\n         }\r\n      }\r\n\r\n      Visual _child;\r\n      <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">virtual</span> Visual Child\r\n      {\r\n         <span style=\"color:Blue\">get</span>\r\n         {\r\n            <span style=\"color:Blue\">return</span> _child;\r\n         }\r\n         <span style=\"color:Blue\">set</span>\r\n         {\r\n            <span style=\"color:Blue\">if</span>(_child != value)\r\n            {\r\n               <span style=\"color:Blue\">if</span>(_child != <span style=\"color:Blue\">null</span>)\r\n               {\r\n                  RemoveLogicalChild(_child);\r\n                  RemoveVisualChild(_child);\r\n               }\r\n\r\n               <span style=\"color:Blue\">if</span>(value != <span style=\"color:Blue\">null</span>)\r\n               {\r\n                  AddVisualChild(value);\r\n                  AddLogicalChild(value);\r\n               }\r\n\r\n               <span style=\"color:Green\">// cache the new child</span>\r\n               _child = value;\r\n\r\n               InvalidateVisual();\r\n            }\r\n         }\r\n      }\r\n\r\n      <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">bool</span> UpdateVisual(<span style=\"color:Blue\">bool</span> forceUpdate)\r\n      {\r\n         <span style=\"color:Blue\">if</span>(forceUpdate || IsChanged)\r\n         {\r\n            Child = Create();\r\n            IsChanged = <span style=\"color:Blue\">false</span>;\r\n            <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">true</span>;\r\n         }\r\n\r\n         <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">false</span>;\r\n      }\r\n\r\n      <span style=\"color:Blue\">int</span> countCreate = 0;\r\n\r\n      <span style=\"color:Blue\">private</span> DrawingVisual Create()\r\n      {\r\n         countCreate++;\r\n\r\n         <span style=\"color:Blue\">var</span> square = <span style=\"color:Blue\">new</span> DrawingVisualFx();\r\n\r\n         <span style=\"color:Blue\">using</span>(DrawingContext dc = square.RenderOpen())\r\n         {\r\n            dc.DrawEllipse(<span style=\"color:Blue\">null</span>, Stroke, <span style=\"color:Blue\">new</span> Point(Width/2, Height/2), Width/2 + Stroke.Thickness/2, Height/2 + Stroke.Thickness/2);\r\n\r\n            <span style=\"color:Green\">//dc.DrawLine(StrokeArrow, new Point(-Width*0.5, Height*0.5), new Point(Width*1.5, Height*0.5));</span>\r\n            <span style=\"color:Green\">//dc.DrawLine(StrokeArrow, new Point(Width*0.5, -Height*0.5), new Point(Width*0.5, Height*1.5));</span>\r\n\r\n            <span style=\"color:Blue\">if</span>(Angle.HasValue)\r\n            {\r\n               dc.PushTransform(<span style=\"color:Blue\">new</span> RotateTransform(Angle.Value, Width/2, Height/2));\r\n               {\r\n                  PolyLineSegment polySeg = <span style=\"color:Blue\">new</span> PolyLineSegment(<span style=\"color:Blue\">new</span> Point[] { <span style=\"color:Blue\">new</span> Point(Width*0.2, Height*0.3), <span style=\"color:Blue\">new</span> Point(Width*0.8, Height*0.3) }, <span style=\"color:Blue\">true</span>);\r\n                  PathFigure pathFig = <span style=\"color:Blue\">new</span> PathFigure(<span style=\"color:Blue\">new</span> Point(Width*0.5, -Height*0.22), <span style=\"color:Blue\">new</span> PathSegment[] { polySeg }, <span style=\"color:Blue\">true</span>);\r\n                  PathGeometry pathGeo = <span style=\"color:Blue\">new</span> PathGeometry(<span style=\"color:Blue\">new</span> PathFigure[] { pathFig });\r\n                  dc.DrawGeometry(Brushes.AliceBlue, StrokeArrow, pathGeo);\r\n               }\r\n               dc.Pop();\r\n            }\r\n\r\n            dc.DrawEllipse(Background, <span style=\"color:Blue\">null</span>, <span style=\"color:Blue\">new</span> Point(Width/2, Height/2), Width/2, Height/2);\r\n            dc.DrawText(FText, <span style=\"color:Blue\">new</span> Point(Width/2 - FText.Width/2, Height/2 - FText.Height/2));\r\n         }\r\n\r\n         <span style=\"color:Blue\">return</span> square;\r\n      }\r\n\r\n      <span style=\"color:Blue\">#region</span> Necessary Overrides -- Needed by WPF to maintain bookkeeping of our hosted visuals\r\n      <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">int</span> VisualChildrenCount\r\n      {\r\n         <span style=\"color:Blue\">get</span>\r\n         {\r\n            <span style=\"color:Blue\">return</span> (Child == <span style=\"color:Blue\">null</span> ? 0 : 1);\r\n         }\r\n      }\r\n\r\n      <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">override</span> Visual GetVisualChild(<span style=\"color:Blue\">int</span> index)\r\n      {\r\n         <span style=\"color:Blue\">return</span> Child;\r\n      }\r\n      <span style=\"color:Blue\">#endregion</span>\r\n   }\r\n</pre>\r\n</div>",
    "PostedDate": "2010-03-06T07:19:29.703-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "414987",
    "ThreadId": "203961",
    "Html": "<p>Pardon me radioman. I write Windows Application. And I have solved now.</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">namespace</span> GMap.NET.WindowsForms.Markers\r\n{\r\n    <span style=\"color:Blue\">using</span> System.Drawing;\r\n    <span style=\"color:Blue\">using</span> System.Windows.Forms.Properties;\r\n    <span style=\"color:Blue\">using</span> System;\r\n    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> GMapMarkerDirection : GMapMarker\r\n    {\r\n        <span style=\"color:Blue\">float</span> Ang;\r\n        <span style=\"color:Blue\">public</span> GMapMarkerDirection(PointLatLng p,<span style=\"color:Blue\">float</span> angle)\r\n            : <span style=\"color:Blue\">base</span>(p)\r\n        {\r\n            Ang = angle;\r\n        }\r\n\r\n        <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> <span style=\"color:Blue\">void</span> OnRender(Graphics g)\r\n        {\r\n\r\n            g.DrawImageUnscaled(RotateImage(Resources.arrow, Ang), LocalPosition.X - Resources.arrow.Width / 2, LocalPosition.Y - Resources.arrow.Height / 2);\r\n        }\r\n\r\n        <span style=\"color:Green\">//http://www.codeproject.com/KB/graphics/rotateimage.aspx</span>\r\n        <span style=\"color:Green\">//Author : James T. Johnson</span>\r\n        <span style=\"color:Blue\">private</span> <span style=\"color:Blue\">static</span> Bitmap RotateImage(Image image, <span style=\"color:Blue\">float</span> angle)\r\n        {\r\n            <span style=\"color:Blue\">if</span> (image == <span style=\"color:Blue\">null</span>)\r\n                <span style=\"color:Blue\">throw</span> <span style=\"color:Blue\">new</span> ArgumentNullException(<span style=\"color:#A31515\">&quot;image&quot;</span>);\r\n\r\n            <span style=\"color:Blue\">const</span> <span style=\"color:Blue\">double</span> pi2 = Math.PI / 2.0;\r\n\r\n            <span style=\"color:Green\">// Why can't C# allow these to be const, or at least readonly</span>\r\n            <span style=\"color:Green\">// *sigh*  I'm starting to talk like Christian Graus :omg:</span>\r\n            <span style=\"color:Blue\">double</span> oldWidth = (<span style=\"color:Blue\">double</span>)image.Width;\r\n            <span style=\"color:Blue\">double</span> oldHeight = (<span style=\"color:Blue\">double</span>)image.Height;\r\n\r\n            <span style=\"color:Green\">// Convert degrees to radians</span>\r\n            <span style=\"color:Blue\">double</span> theta = ((<span style=\"color:Blue\">double</span>)angle) * Math.PI / 180.0;\r\n            <span style=\"color:Blue\">double</span> locked_theta = theta;\r\n\r\n            <span style=\"color:Green\">// Ensure theta is now [0, 2pi)</span>\r\n            <span style=\"color:Blue\">while</span> (locked_theta &lt; 0.0)\r\n                locked_theta += 2 * Math.PI;\r\n\r\n            <span style=\"color:Blue\">double</span> newWidth, newHeight;\r\n            <span style=\"color:Blue\">int</span> nWidth, nHeight; <span style=\"color:Green\">// The newWidth/newHeight expressed as ints</span>\r\n\r\n            <span style=\"color:Blue\">#region</span> Explaination of the calculations\r\n            <span style=\"color:Green\">/*\r\n\t\t\t * The trig involved in calculating the new width and height\r\n\t\t\t * is fairly simple; the hard part was remembering that when \r\n\t\t\t * PI/2 &lt;= theta &lt;= PI and 3PI/2 &lt;= theta &lt; 2PI the width and \r\n\t\t\t * height are switched.\r\n\t\t\t * \r\n\t\t\t * When you rotate a rectangle, r, the bounding box surrounding r\r\n\t\t\t * contains for right-triangles of empty space.  Each of the \r\n\t\t\t * triangles hypotenuse's are a known length, either the width or\r\n\t\t\t * the height of r.  Because we know the length of the hypotenuse\r\n\t\t\t * and we have a known angle of rotation, we can use the trig\r\n\t\t\t * function identities to find the length of the other two sides.\r\n\t\t\t * \r\n\t\t\t * sine = opposite/hypotenuse\r\n\t\t\t * cosine = adjacent/hypotenuse\r\n\t\t\t * \r\n\t\t\t * solving for the unknown we get\r\n\t\t\t * \r\n\t\t\t * opposite = sine * hypotenuse\r\n\t\t\t * adjacent = cosine * hypotenuse\r\n\t\t\t * \r\n\t\t\t * Another interesting point about these triangles is that there\r\n\t\t\t * are only two different triangles. The proof for which is easy\r\n\t\t\t * to see, but its been too long since I've written a proof that\r\n\t\t\t * I can't explain it well enough to want to publish it.  \r\n\t\t\t * \r\n\t\t\t * Just trust me when I say the triangles formed by the lengths \r\n\t\t\t * width are always the same (for a given theta) and the same \r\n\t\t\t * goes for the height of r.\r\n\t\t\t * \r\n\t\t\t * Rather than associate the opposite/adjacent sides with the\r\n\t\t\t * width and height of the original bitmap, I'll associate them\r\n\t\t\t * based on their position.\r\n\t\t\t * \r\n\t\t\t * adjacent/oppositeTop will refer to the triangles making up the \r\n\t\t\t * upper right and lower left corners\r\n\t\t\t * \r\n\t\t\t * adjacent/oppositeBottom will refer to the triangles making up \r\n\t\t\t * the upper left and lower right corners\r\n\t\t\t * \r\n\t\t\t * The names are based on the right side corners, because thats \r\n\t\t\t * where I did my work on paper (the right side).\r\n\t\t\t * \r\n\t\t\t * Now if you draw this out, you will see that the width of the \r\n\t\t\t * bounding box is calculated by adding together adjacentTop and \r\n\t\t\t * oppositeBottom while the height is calculate by adding \r\n\t\t\t * together adjacentBottom and oppositeTop.\r\n\t\t\t */</span>\r\n            <span style=\"color:Blue\">#endregion</span>\r\n\r\n            <span style=\"color:Blue\">double</span> adjacentTop, oppositeTop;\r\n            <span style=\"color:Blue\">double</span> adjacentBottom, oppositeBottom;\r\n\r\n            <span style=\"color:Green\">// We need to calculate the sides of the triangles based</span>\r\n            <span style=\"color:Green\">// on how much rotation is being done to the bitmap.</span>\r\n            <span style=\"color:Green\">//   Refer to the first paragraph in the explaination above for </span>\r\n            <span style=\"color:Green\">//   reasons why.</span>\r\n            <span style=\"color:Blue\">if</span> ((locked_theta &gt;= 0.0 &amp;&amp; locked_theta &lt; pi2) ||\r\n                (locked_theta &gt;= Math.PI &amp;&amp; locked_theta &lt; (Math.PI + pi2)))\r\n            {\r\n                adjacentTop = Math.Abs(Math.Cos(locked_theta)) * oldWidth;\r\n                oppositeTop = Math.Abs(Math.Sin(locked_theta)) * oldWidth;\r\n\r\n                adjacentBottom = Math.Abs(Math.Cos(locked_theta)) * oldHeight;\r\n                oppositeBottom = Math.Abs(Math.Sin(locked_theta)) * oldHeight;\r\n            }\r\n            <span style=\"color:Blue\">else</span>\r\n            {\r\n                adjacentTop = Math.Abs(Math.Sin(locked_theta)) * oldHeight;\r\n                oppositeTop = Math.Abs(Math.Cos(locked_theta)) * oldHeight;\r\n\r\n                adjacentBottom = Math.Abs(Math.Sin(locked_theta)) * oldWidth;\r\n                oppositeBottom = Math.Abs(Math.Cos(locked_theta)) * oldWidth;\r\n            }\r\n\r\n            newWidth = adjacentTop + oppositeBottom;\r\n            newHeight = adjacentBottom + oppositeTop;\r\n\r\n            nWidth = (<span style=\"color:Blue\">int</span>)Math.Ceiling(newWidth);\r\n            nHeight = (<span style=\"color:Blue\">int</span>)Math.Ceiling(newHeight);\r\n\r\n            Bitmap rotatedBmp = <span style=\"color:Blue\">new</span> Bitmap(nWidth, nHeight);\r\n\r\n            <span style=\"color:Blue\">using</span> (Graphics g = Graphics.FromImage(rotatedBmp))\r\n            {\r\n                <span style=\"color:Green\">// This array will be used to pass in the three points that </span>\r\n                <span style=\"color:Green\">// make up the rotated image</span>\r\n                Point[] points;\r\n\r\n                <span style=\"color:Green\">/*\r\n                 * The values of opposite/adjacentTop/Bottom are referring to \r\n                 * fixed locations instead of in relation to the\r\n                 * rotating image so I need to change which values are used\r\n                 * based on the how much the image is rotating.\r\n                 * \r\n                 * For each point, one of the coordinates will always be 0, \r\n                 * nWidth, or nHeight.  This because the Bitmap we are drawing on\r\n                 * is the bounding box for the rotated bitmap.  If both of the \r\n                 * corrdinates for any of the given points wasn't in the set above\r\n                 * then the bitmap we are drawing on WOULDN'T be the bounding box\r\n                 * as required.\r\n                 */</span>\r\n                <span style=\"color:Blue\">if</span> (locked_theta &gt;= 0.0 &amp;&amp; locked_theta &lt; pi2)\r\n                {\r\n                    points = <span style=\"color:Blue\">new</span> Point[] { \r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( (<span style=\"color:Blue\">int</span>) oppositeBottom, 0 ), \r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( nWidth, (<span style=\"color:Blue\">int</span>) oppositeTop ),\r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( 0, (<span style=\"color:Blue\">int</span>) adjacentBottom )\r\n\t\t\t\t\t\t\t\t\t\t };\r\n\r\n                }\r\n                <span style=\"color:Blue\">else</span> <span style=\"color:Blue\">if</span> (locked_theta &gt;= pi2 &amp;&amp; locked_theta &lt; Math.PI)\r\n                {\r\n                    points = <span style=\"color:Blue\">new</span> Point[] { \r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( nWidth, (<span style=\"color:Blue\">int</span>) oppositeTop ),\r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( (<span style=\"color:Blue\">int</span>) adjacentTop, nHeight ),\r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( (<span style=\"color:Blue\">int</span>) oppositeBottom, 0 )\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t\t\t\t };\r\n                }\r\n                <span style=\"color:Blue\">else</span> <span style=\"color:Blue\">if</span> (locked_theta &gt;= Math.PI &amp;&amp; locked_theta &lt; (Math.PI + pi2))\r\n                {\r\n                    points = <span style=\"color:Blue\">new</span> Point[] { \r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( (<span style=\"color:Blue\">int</span>) adjacentTop, nHeight ), \r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( 0, (<span style=\"color:Blue\">int</span>) adjacentBottom ),\r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( nWidth, (<span style=\"color:Blue\">int</span>) oppositeTop )\r\n\t\t\t\t\t\t\t\t\t\t };\r\n                }\r\n                <span style=\"color:Blue\">else</span>\r\n                {\r\n                    points = <span style=\"color:Blue\">new</span> Point[] { \r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( 0, (<span style=\"color:Blue\">int</span>) adjacentBottom ), \r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( (<span style=\"color:Blue\">int</span>) oppositeBottom, 0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t <span style=\"color:Blue\">new</span> Point( (<span style=\"color:Blue\">int</span>) adjacentTop, nHeight )\t\t\r\n\t\t\t\t\t\t\t\t\t\t };\r\n                }\r\n\r\n                g.DrawImage(image, points);\r\n            }\r\n\r\n            <span style=\"color:Blue\">return</span> rotatedBmp;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-03-06T08:07:44.09-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "415039",
    "ThreadId": "203961",
    "Html": "<p>ohh you using windows forms, actually you can push transformation:</p>\r\n<p>g.RotateTransform(15);</p>\r\n<p>g.Draw(...);</p>\r\n<p>g.ResetTransform();</p>",
    "PostedDate": "2010-03-06T12:43:38.307-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "415063",
    "ThreadId": "203961",
    "Html": "<p>I've tried it&nbsp;and it's runing but image's changed. Markers shows half.</p>",
    "PostedDate": "2010-03-06T14:23:17.747-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "415073",
    "ThreadId": "203961",
    "Html": "<p>you can only paint transformed arrow not all image</p>",
    "PostedDate": "2010-03-06T15:52:13.117-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]