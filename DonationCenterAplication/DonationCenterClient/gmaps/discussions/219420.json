[
  {
    "Id": "467246",
    "ThreadId": "219420",
    "Html": "<p>The problem is pretty simple: in GMap.Net tiles are loaded in separate threads, and in every thread the following code is executed:</p>\r\n<p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>\r\n                     <span style=\"color:blue\">if</span> (!IsDragging)\r\n                     {\r\n                         <span style=\"color:blue\">if</span> (OnNeedInvalidation != <span style=\"color:blue\">null</span>)\r\n                         {\r\n                             OnNeedInvalidation();\r\n                         }\r\n                     }\r\n</pre>\r\n</div>\r\n</p>\r\n<p>(see void ProcessLoadTask(object obj) method in Core.cs for details)</p>\r\n<p>&nbsp;</p>\r\n<p>Because of that, on every load of tiles (on application start, zoom change and so on) there are many calls of OnNeedInvalidation(), and that indirectly calls OnRender() as many times as the number of tiles we have.</p>\r\n<p>You can easily reproduce the problem with the following Map class (replace existing one in WPF Demo).</p>\r\n<p>&nbsp;</p>\r\n<p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre><span style=\"color:gray\">    ///</span> <span style=\"color:gray\">&lt;summary&gt;</span>\r\n    <span style=\"color:gray\">///</span><span style=\"color:green\"> the custom map f GMapControl </span>\r\n    <span style=\"color:gray\">///</span> <span style=\"color:gray\">&lt;/summary&gt;</span>\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> Map : GMapControl\r\n    {\r\n        <span style=\"color:blue\">private</span> <span style=\"color:blue\">int</span> counter;\r\n\r\n        <span style=\"color:blue\">public</span> Map()\r\n        {\r\n            <span style=\"color:green\">// ...</span>\r\n        }\r\n\r\n        <span style=\"color:gray\">///</span> <span style=\"color:gray\">&lt;summary&gt;</span>\r\n        <span style=\"color:gray\">///</span><span style=\"color:green\"> any custom drawing here</span>\r\n        <span style=\"color:gray\">///</span> <span style=\"color:gray\">&lt;/summary&gt;</span>\r\n        <span style=\"color:gray\">///</span> <span style=\"color:gray\">&lt;param name=&quot;drawingContext&quot;&gt;</span><span style=\"color:gray\">&lt;/param&gt;</span>\r\n        <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> OnRender(DrawingContext drawingContext)\r\n        {\r\n            <span style=\"color:blue\">base</span>.OnRender(drawingContext);\r\n\r\n            counter++;\r\n            FormattedText text = <span style=\"color:blue\">new</span> FormattedText(counter.ToString(), CultureInfo.CurrentUICulture,\r\n                <span style=\"color:blue\">new</span> FlowDirection(), <span style=\"color:blue\">new</span> Typeface(<span style=\"color:#a31515\">&quot;GenericSansSerif&quot;</span>), 36, Brushes.Orange);\r\n            drawingContext.DrawText(text, <span style=\"color:blue\">new</span> Point(5, 5));\r\n\r\n            Random r = <span style=\"color:blue\">new</span> Random();\r\n            <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> i = 0; i &lt; 50; i++)\r\n            {\r\n                drawingContext.DrawLine(SelectionPen, <span style=\"color:blue\">new</span> Point(r.Next(1600), r.Next(900)), <span style=\"color:blue\">new</span> Point(r.Next(1600), r.Next(900)));\r\n            }\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n</p>\r\n<p>My initial solution of this problem was to change logic in Core.cs is such a manner that only the last tile will start invalidation. For that I just moved the code shown in the first code snippet two lines higher (inside this condition):</p>\r\n<p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>                  <span style=\"color:green\">// last buddy cleans stuff ;}</span>\r\n                  <span style=\"color:blue\">if</span>(last)\r\n                  {\r\n...\r\n                  }\r\n</pre>\r\n</div>\r\nThis works for 99% of times, but sometimes some tiles are not shown. I guess this is because of asyncronous calls. Am I correct? Is it possible to solve this problem in a better way? Thanks in advance!</p>",
    "PostedDate": "2010-07-14T05:59:12.187-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467253",
    "ThreadId": "219420",
    "Html": "well, if you invalidate only after the last tile, then view will be empty most of the time. If you have code thats solve these problems, please share ;}\r\n\r\np.s. i have new wpf system on the way, using canvas, so invalidation overhead would be solved automaticaly",
    "PostedDate": "2010-07-14T06:08:33.69-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467275",
    "ThreadId": "219420",
    "Html": "<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>radioman wrote:</strong><br>well, if you invalidate only after the last tile, then view will be empty most of the time. If you have code thats solve these problems, please share ;}  p.s. i have new wpf system on the way, using canvas, so invalidation overhead would be solved automaticaly</blockquote>\r\n<p>Radioman, thank you for your quick reply!</p>\r\n<p>1. The view is not empty for 99% of time in my current solution. But it doesn't work for 100%, unfortunately.</p>\r\n<p>2. What is your roadmap for this new WPF version? Will it be available within a week, month or year? :) Is it partially done/committed? It would be interesting to take a look.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-07-14T06:48:44.187-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467306",
    "ThreadId": "219420",
    "Html": "check Testing\\WPF-GMapControlNew, it is available now, but useful just for testing.\r\np.s. now it should invalidate 100% ;}",
    "PostedDate": "2010-07-14T07:55:33.597-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467586",
    "ThreadId": "219420",
    "Html": "<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>radioman wrote:</strong><br>check Testing\\WPF-GMapControlNew, it is available now, but useful just for testing. p.s. now it should invalidate 100% ;}</blockquote>\r\n<p>1. Will definitely take a look at this new control, thanks!</p>\r\n<p>2. It doesn't invalidate in 100% of cases, unfortunately:</p>\r\n<p>http://www.picfront.org/d/7IP7</p>\r\n<p>(I reproduced that by zoom/unzoom).</p>\r\n<p>&nbsp;</p>\r\n<p>I think the logic for invalidation should be as follows:</p>\r\n<p>1. Wait for ALL threads to finish.</p>\r\n<p>2. Execute some method that will perform invalidation.</p>\r\n<p>&nbsp;</p>\r\n<p>I'm not so familiar with thread programming, but I guess something like EventWaitHandle should be used for enabling thread syncronization.<strong><br></strong></p>",
    "PostedDate": "2010-07-14T23:25:13.073-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467588",
    "ThreadId": "219420",
    "Html": "<p>did you test it on 6e4b902bd621 changeset?</p>",
    "PostedDate": "2010-07-14T23:33:17.97-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467600",
    "ThreadId": "219420",
    "Html": "<p>Yes, I've tested on that one.</p>\r\n<p>I tried the following change, but it doesn't work in STA apartment:</p>\r\n<p>&nbsp;</p>\r\n<p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>            <span style=\"color:green\">// One event is used for each tile load task.</span>\r\n            ManualResetEvent[] doneEvents = <span style=\"color:blue\">new</span> ManualResetEvent[tileDrawingList.Count];\r\n            <span style=\"color:blue\">int</span> eventNumber = 0;\r\n\r\n            <span style=\"color:blue\">foreach</span>(Point p <span style=\"color:blue\">in</span> tileDrawingList)\r\n            {\r\n               LoadTask task = <span style=\"color:blue\">new</span> LoadTask(p, Zoom);\r\n               {\r\n                  <span style=\"color:blue\">lock</span>(tileLoadQueue)\r\n                  {\r\n                     <span style=\"color:blue\">if</span>(!tileLoadQueue.Contains(task))\r\n                     {\r\n                        doneEvents[eventNumber] = <span style=\"color:blue\">new</span> ManualResetEvent(<span style=\"color:blue\">false</span>);\r\n                        tileLoadQueue.Enqueue(task);\r\n                        ThreadPool.QueueUserWorkItem(ProcessLoadTaskCallback, doneEvents[eventNumber]);\r\n                     }\r\n                     <span style=\"color:blue\">else</span>\r\n                     {\r\n                         <span style=\"color:green\">// Loading of this tile has finished.</span>\r\n                         doneEvents[eventNumber] = <span style=\"color:blue\">new</span> ManualResetEvent(<span style=\"color:blue\">true</span>);\r\n                     }\r\n                  }\r\n               }\r\n               eventNumber++;\r\n            }\r\n\r\n            <span style=\"color:green\">// Wait for all threads in pool.</span>\r\n            WaitHandle.WaitAll(doneEvents);\r\n</pre>\r\n</div>\r\n</p>\r\n<p>I guess I will try to solve this problem in an hour or so, and will post the results here.</p>",
    "PostedDate": "2010-07-15T00:08:25.983-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467605",
    "ThreadId": "219420",
    "Html": "<p>So here is the solution (sorry, I don't know how to send you a patch without commit):</p>\r\n<p>&nbsp;</p>\r\n<p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>diff --git a/GMap.NET.Core/GMap.NET.Internals/Core.cs b/GMap.NET.Core/GMap.NET.Internals/Core.cs\r\n--- a/GMap.NET.Core/GMap.NET.Internals/Core.cs\r\n+++ b/GMap.NET.Core/GMap.NET.Internals/Core.cs\r\n@@ -47,6 +47,7 @@\r\n \r\n\r\n       <span style=\"color:blue\">public</span> <span style=\"color:blue\">readonly</span> Queue&lt;LoadTask&gt; tileLoadQueue = <span style=\"color:blue\">new</span> Queue&lt;LoadTask&gt;();\r\n\r\n       <span style=\"color:blue\">readonly</span> WaitCallback ProcessLoadTaskCallback;\r\n\r\n+      <span style=\"color:blue\">readonly</span> WaitCallback ProcessInvalidationCallback;\r\n\r\n \r\n\r\n       <span style=\"color:blue\">public</span> <span style=\"color:blue\">static</span> <span style=\"color:blue\">readonly</span> <span style=\"color:blue\">string</span> googleCopyright = <span style=\"color:blue\">string</span>.Format(<span style=\"color:#a31515\">&quot;&copy;{0} Google - Map data &copy;{0} Tele Atlas, Imagery &copy;{0} TerraMetrics&quot;</span>, DateTime.Today.Year);\r\n\r\n       <span style=\"color:blue\">public</span> <span style=\"color:blue\">static</span> <span style=\"color:blue\">readonly</span> <span style=\"color:blue\">string</span> openStreetMapCopyright = <span style=\"color:blue\">string</span>.Format(<span style=\"color:#a31515\">&quot;&copy; OpenStreetMap - Map data &copy;{0} OpenStreetMap&quot;</span>, DateTime.Today.Year);\r\n\r\n@@ -410,6 +411,7 @@\r\n       <span style=\"color:blue\">public</span> Core()\r\n\r\n       {\r\n\r\n          ProcessLoadTaskCallback = <span style=\"color:blue\">new</span> WaitCallback(ProcessLoadTask);\r\n\r\n+         ProcessInvalidationCallback = <span style=\"color:blue\">new</span> WaitCallback(ProcessInvalidation);\r\n\r\n \r\n\r\n <span style=\"color:blue\">#if</span> PocketPC\r\n\r\n          loaderLimit = <span style=\"color:blue\">new</span> Semaphore(2, 2);\r\n\r\n@@ -937,6 +939,8 @@\r\n \r\n\r\n       <span style=\"color:blue\">void</span> ProcessLoadTask(<span style=\"color:blue\">object</span> obj)\r\n\r\n       {\r\n\r\n+         ManualResetEvent doneEvent = (ManualResetEvent) obj;\r\n\r\n+\r\n\r\n          <span style=\"color:blue\">bool</span> last = <span style=\"color:blue\">false</span>;\r\n\r\n \r\n\r\n          LoadTask? task = <span style=\"color:blue\">null</span>;\r\n\r\n@@ -1088,42 +1092,40 @@\r\n                      {\r\n\r\n                         OnTileLoadComplete();\r\n\r\n                      }\r\n\r\n+                  }\r\n\r\n \r\n\r\n-                     <span style=\"color:blue\">if</span>(OnNeedInvalidation != <span style=\"color:blue\">null</span>)\r\n\r\n-                     {\r\n\r\n-                        Thread.Sleep(333);\r\n\r\n-                        OnNeedInvalidation();\r\n\r\n-                     }\r\n\r\n-                     <span style=\"color:blue\">lock</span>(<span style=\"color:blue\">this</span>)\r\n\r\n-                     {\r\n\r\n-                        LastInvalidation = DateTime.Now;\r\n\r\n-                     }\r\n\r\n-                  }\r\n\r\n-                  <span style=\"color:blue\">else</span>\r\n\r\n-                  {\r\n\r\n-                     <span style=\"color:blue\">lock</span>(<span style=\"color:blue\">this</span>)\r\n\r\n-                     {\r\n\r\n-                        <span style=\"color:blue\">if</span>((DateTime.Now - LastInvalidation).TotalMilliseconds &gt; 111)\r\n\r\n-                        {\r\n\r\n-                           <span style=\"color:blue\">if</span>(OnNeedInvalidation != <span style=\"color:blue\">null</span>)\r\n\r\n-                           {\r\n\r\n-                              OnNeedInvalidation();\r\n\r\n-                           }\r\n\r\n-                           LastInvalidation = DateTime.Now;\r\n\r\n-                        }\r\n\r\n-                        <span style=\"color:blue\">else</span>\r\n\r\n-                        {\r\n\r\n-                           Debug.WriteLine(<span style=\"color:#a31515\">&quot;SkipInvalidation, Delta: &quot;</span> + (DateTime.Now - LastInvalidation).TotalMilliseconds + <span style=\"color:#a31515\">&quot;ms&quot;</span>);\r\n\r\n-                        }\r\n\r\n-                     }\r\n\r\n-                  }\r\n\r\n+                  <span style=\"color:green\">//if(!IsDragging)</span>\r\n\r\n+                  <span style=\"color:green\">//{</span>\r\n\r\n+                  <span style=\"color:green\">//   if(OnNeedInvalidation != null)</span>\r\n\r\n+                  <span style=\"color:green\">//   {</span>\r\n\r\n+                  <span style=\"color:green\">//      OnNeedInvalidation();</span>\r\n\r\n+                  <span style=\"color:green\">//   }</span>\r\n\r\n+                  <span style=\"color:green\">//}</span>\r\n\r\n                }\r\n\r\n             }\r\n\r\n             loaderLimit.Release();\r\n\r\n          }\r\n\r\n+\r\n\r\n+         <span style=\"color:green\">// Notify that this thread has finished.</span>\r\n\r\n+         doneEvent.Set();\r\n\r\n       }\r\n\r\n \r\n\r\n-      DateTime LastInvalidation = DateTime.Now;\r\n\r\n+      <span style=\"color:blue\">void</span> ProcessInvalidation(<span style=\"color:blue\">object</span> obj)\r\n\r\n+      {\r\n\r\n+          ManualResetEvent[] doneEvents = (ManualResetEvent[]) obj;\r\n\r\n+\r\n\r\n+          <span style=\"color:green\">// Wait for all threads in pool.</span>\r\n\r\n+          WaitHandle.WaitAll(doneEvents);\r\n\r\n+\r\n\r\n+          <span style=\"color:blue\">if</span> (!IsDragging)\r\n\r\n+          {\r\n\r\n+              <span style=\"color:blue\">if</span> (OnNeedInvalidation != <span style=\"color:blue\">null</span>)\r\n\r\n+              {\r\n\r\n+                  OnNeedInvalidation();\r\n\r\n+              }\r\n\r\n+          }\r\n\r\n+      }\r\n\r\n+\r\n\r\n \r\n\r\n       <span style=\"color:gray\">///</span> <span style=\"color:gray\">&lt;summary&gt;</span>\r\n\r\n       <span style=\"color:gray\">///</span><span style=\"color:green\"> updates map bounds</span>\r\n\r\n@@ -1150,6 +1152,10 @@\r\n             }\r\n\r\n <span style=\"color:blue\">#endif</span>\r\n\r\n \r\n\r\n+            <span style=\"color:green\">// One ManualResetEvent is used for each tile load task.</span>\r\n\r\n+            ManualResetEvent[] doneEvents = <span style=\"color:blue\">new</span> ManualResetEvent[tileDrawingList.Count];\r\n\r\n+\r\n\r\n+            <span style=\"color:blue\">int</span> eventNumber = 0;\r\n\r\n             <span style=\"color:blue\">foreach</span>(Point p <span style=\"color:blue\">in</span> tileDrawingList)\r\n\r\n             {\r\n\r\n                LoadTask task = <span style=\"color:blue\">new</span> LoadTask(p, Zoom);\r\n\r\n@@ -1158,12 +1164,22 @@\r\n                   {\r\n\r\n                      <span style=\"color:blue\">if</span>(!tileLoadQueue.Contains(task))\r\n\r\n                      {\r\n\r\n+                        doneEvents[eventNumber] = <span style=\"color:blue\">new</span> ManualResetEvent(<span style=\"color:blue\">false</span>);\r\n\r\n                         tileLoadQueue.Enqueue(task);\r\n\r\n-                        ThreadPool.QueueUserWorkItem(ProcessLoadTaskCallback);\r\n\r\n+                        ThreadPool.QueueUserWorkItem(ProcessLoadTaskCallback, doneEvents[eventNumber]);\r\n\r\n+                     }\r\n\r\n+                     <span style=\"color:blue\">else</span>\r\n\r\n+                     {\r\n\r\n+                         <span style=\"color:green\">// Loading of this tile has finished.</span>\r\n\r\n+                         doneEvents[eventNumber] = <span style=\"color:blue\">new</span> ManualResetEvent(<span style=\"color:blue\">true</span>);\r\n\r\n                      }\r\n\r\n                   }\r\n\r\n                }\r\n\r\n+               eventNumber++;\r\n\r\n             }\r\n\r\n+\r\n\r\n+            <span style=\"color:green\">// Start invalidation thread that will wait finishing of all tile load tasks and then will perform invalidation.</span>\r\n\r\n+            ThreadPool.QueueUserWorkItem(ProcessInvalidationCallback, doneEvents);\r\n\r\n          }\r\n\r\n          <span style=\"color:blue\">finally</span>\r\n\r\n          {\r\n\r\n\r\n</pre>\r\n</div>\r\n</p>\r\n<p>The only (evident) side effect is that all tiles are now shown simultaneusly, after their loading :)</p>",
    "PostedDate": "2010-07-15T00:23:23.243-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467613",
    "ThreadId": "219420",
    "Html": "<p>Radioman, I finally combined yours and mine solutions. Here it is:</p>\r\n<p>&nbsp;</p>\r\n<p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>diff --git a/GMap.NET.Core/GMap.NET.Internals/Core.cs b/GMap.NET.Core/GMap.NET.Internals/Core.cs\r\n--- a/GMap.NET.Core/GMap.NET.Internals/Core.cs\r\n+++ b/GMap.NET.Core/GMap.NET.Internals/Core.cs\r\n@@ -47,6 +47,7 @@\r\n \r\n\r\n       <span style=\"color:blue\">public</span> <span style=\"color:blue\">readonly</span> Queue&lt;LoadTask&gt; tileLoadQueue = <span style=\"color:blue\">new</span> Queue&lt;LoadTask&gt;();\r\n\r\n       <span style=\"color:blue\">readonly</span> WaitCallback ProcessLoadTaskCallback;\r\n\r\n+      <span style=\"color:blue\">readonly</span> WaitCallback ProcessInvalidationCallback;\r\n\r\n \r\n\r\n       <span style=\"color:blue\">public</span> <span style=\"color:blue\">static</span> <span style=\"color:blue\">readonly</span> <span style=\"color:blue\">string</span> googleCopyright = <span style=\"color:blue\">string</span>.Format(<span style=\"color:#a31515\">&quot;&copy;{0} Google - Map data &copy;{0} Tele Atlas, Imagery &copy;{0} TerraMetrics&quot;</span>, DateTime.Today.Year);\r\n\r\n       <span style=\"color:blue\">public</span> <span style=\"color:blue\">static</span> <span style=\"color:blue\">readonly</span> <span style=\"color:blue\">string</span> openStreetMapCopyright = <span style=\"color:blue\">string</span>.Format(<span style=\"color:#a31515\">&quot;&copy; OpenStreetMap - Map data &copy;{0} OpenStreetMap&quot;</span>, DateTime.Today.Year);\r\n\r\n@@ -410,6 +411,7 @@\r\n       <span style=\"color:blue\">public</span> Core()\r\n\r\n       {\r\n\r\n          ProcessLoadTaskCallback = <span style=\"color:blue\">new</span> WaitCallback(ProcessLoadTask);\r\n\r\n+         ProcessInvalidationCallback = <span style=\"color:blue\">new</span> WaitCallback(ProcessInvalidation);\r\n\r\n \r\n\r\n <span style=\"color:blue\">#if</span> PocketPC\r\n\r\n          loaderLimit = <span style=\"color:blue\">new</span> Semaphore(2, 2);\r\n\r\n@@ -937,6 +939,8 @@\r\n \r\n\r\n       <span style=\"color:blue\">void</span> ProcessLoadTask(<span style=\"color:blue\">object</span> obj)\r\n\r\n       {\r\n\r\n+         ManualResetEvent doneEvent = (ManualResetEvent) obj;\r\n\r\n+\r\n\r\n          <span style=\"color:blue\">bool</span> last = <span style=\"color:blue\">false</span>;\r\n\r\n \r\n\r\n          LoadTask? task = <span style=\"color:blue\">null</span>;\r\n\r\n@@ -1088,42 +1092,48 @@\r\n                      {\r\n\r\n                         OnTileLoadComplete();\r\n\r\n                      }\r\n\r\n+                  }\r\n\r\n \r\n\r\n-                     <span style=\"color:blue\">if</span>(OnNeedInvalidation != <span style=\"color:blue\">null</span>)\r\n\r\n-                     {\r\n\r\n-                        Thread.Sleep(333);\r\n\r\n-                        OnNeedInvalidation();\r\n\r\n-                     }\r\n\r\n-                     <span style=\"color:blue\">lock</span>(<span style=\"color:blue\">this</span>)\r\n\r\n-                     {\r\n\r\n-                        LastInvalidation = DateTime.Now;\r\n\r\n-                     }\r\n\r\n+                  <span style=\"color:green\">// Invalidate 10 times in a second.</span>\r\n\r\n+                  <span style=\"color:blue\">lock</span> (<span style=\"color:blue\">this</span>)\r\n\r\n+                  {\r\n\r\n+                      <span style=\"color:blue\">if</span> ((DateTime.Now - LastInvalidation).TotalMilliseconds &gt; 100)\r\n\r\n+                      {\r\n\r\n+                          <span style=\"color:blue\">if</span> (OnNeedInvalidation != <span style=\"color:blue\">null</span>)\r\n\r\n+                          {\r\n\r\n+                              OnNeedInvalidation();\r\n\r\n+                          }\r\n\r\n+                          LastInvalidation = DateTime.Now;\r\n\r\n+                      }\r\n\r\n                   }\r\n\r\n-                  <span style=\"color:blue\">else</span>\r\n\r\n-                  {\r\n\r\n-                     <span style=\"color:blue\">lock</span>(<span style=\"color:blue\">this</span>)\r\n\r\n-                     {\r\n\r\n-                        <span style=\"color:blue\">if</span>((DateTime.Now - LastInvalidation).TotalMilliseconds &gt; 111)\r\n\r\n-                        {\r\n\r\n-                           <span style=\"color:blue\">if</span>(OnNeedInvalidation != <span style=\"color:blue\">null</span>)\r\n\r\n-                           {\r\n\r\n-                              OnNeedInvalidation();\r\n\r\n-                           }\r\n\r\n-                           LastInvalidation = DateTime.Now;\r\n\r\n-                        }\r\n\r\n-                        <span style=\"color:blue\">else</span>\r\n\r\n-                        {\r\n\r\n-                           Debug.WriteLine(<span style=\"color:#a31515\">&quot;SkipInvalidation, Delta: &quot;</span> + (DateTime.Now - LastInvalidation).TotalMilliseconds + <span style=\"color:#a31515\">&quot;ms&quot;</span>);\r\n\r\n-                        }\r\n\r\n-                     }\r\n\r\n-                  }\r\n\r\n+\r\n\r\n                }\r\n\r\n             }\r\n\r\n             loaderLimit.Release();\r\n\r\n          }\r\n\r\n+\r\n\r\n+         <span style=\"color:green\">// Notify that this thread has finished.</span>\r\n\r\n+         doneEvent.Set();\r\n\r\n       }\r\n\r\n \r\n\r\n-      DateTime LastInvalidation = DateTime.Now;\r\n\r\n+      <span style=\"color:blue\">private</span> DateTime LastInvalidation = DateTime.Now;\r\n\r\n+\r\n\r\n+      <span style=\"color:blue\">void</span> ProcessInvalidation(<span style=\"color:blue\">object</span> obj)\r\n\r\n+      {\r\n\r\n+          ManualResetEvent[] doneEvents = (ManualResetEvent[]) obj;\r\n\r\n+\r\n\r\n+          <span style=\"color:green\">// Wait for all threads in pool.</span>\r\n\r\n+          WaitHandle.WaitAll(doneEvents);\r\n\r\n+\r\n\r\n+          <span style=\"color:blue\">if</span> (!IsDragging)\r\n\r\n+          {\r\n\r\n+              <span style=\"color:blue\">if</span> (OnNeedInvalidation != <span style=\"color:blue\">null</span>)\r\n\r\n+              {\r\n\r\n+                  OnNeedInvalidation();\r\n\r\n+              }\r\n\r\n+          }\r\n\r\n+      }\r\n\r\n+\r\n\r\n \r\n\r\n       <span style=\"color:gray\">///</span> <span style=\"color:gray\">&lt;summary&gt;</span>\r\n\r\n       <span style=\"color:gray\">///</span><span style=\"color:green\"> updates map bounds</span>\r\n\r\n@@ -1150,6 +1160,10 @@\r\n             }\r\n\r\n <span style=\"color:blue\">#endif</span>\r\n\r\n \r\n\r\n+            <span style=\"color:green\">// One ManualResetEvent is used for each tile load task.</span>\r\n\r\n+            ManualResetEvent[] doneEvents = <span style=\"color:blue\">new</span> ManualResetEvent[tileDrawingList.Count];\r\n\r\n+\r\n\r\n+            <span style=\"color:blue\">int</span> eventNumber = 0;\r\n\r\n             <span style=\"color:blue\">foreach</span>(Point p <span style=\"color:blue\">in</span> tileDrawingList)\r\n\r\n             {\r\n\r\n                LoadTask task = <span style=\"color:blue\">new</span> LoadTask(p, Zoom);\r\n\r\n@@ -1158,12 +1172,22 @@\r\n                   {\r\n\r\n                      <span style=\"color:blue\">if</span>(!tileLoadQueue.Contains(task))\r\n\r\n                      {\r\n\r\n+                        doneEvents[eventNumber] = <span style=\"color:blue\">new</span> ManualResetEvent(<span style=\"color:blue\">false</span>);\r\n\r\n                         tileLoadQueue.Enqueue(task);\r\n\r\n-                        ThreadPool.QueueUserWorkItem(ProcessLoadTaskCallback);\r\n\r\n+                        ThreadPool.QueueUserWorkItem(ProcessLoadTaskCallback, doneEvents[eventNumber]);\r\n\r\n+                     }\r\n\r\n+                     <span style=\"color:blue\">else</span>\r\n\r\n+                     {\r\n\r\n+                         <span style=\"color:green\">// Loading of this tile has finished.</span>\r\n\r\n+                         doneEvents[eventNumber] = <span style=\"color:blue\">new</span> ManualResetEvent(<span style=\"color:blue\">true</span>);\r\n\r\n                      }\r\n\r\n                   }\r\n\r\n                }\r\n\r\n+               eventNumber++;\r\n\r\n             }\r\n\r\n+\r\n\r\n+            <span style=\"color:green\">// Start invalidation thread that will wait finishing of all tile load tasks and then will perform invalidation.</span>\r\n\r\n+            ThreadPool.QueueUserWorkItem(ProcessInvalidationCallback, doneEvents);\r\n\r\n          }\r\n\r\n          <span style=\"color:blue\">finally</span>\r\n\r\n          {\r\n\r\n\r\n</pre>\r\n</div>\r\nIt works as previously (from visual perspective), but performance is much better on load and zoom/unzoom.</p>",
    "PostedDate": "2010-07-15T00:48:12.22-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467618",
    "ThreadId": "219420",
    "Html": "<p>I've uploaded a patch.</p>\r\n<p>But... it looks like I've missed the right project... :)</p>\r\n<p>http://offlinemaps.codeplex.com/SourceControl/PatchList.aspx</p>\r\n<p>Radioman, please download it and take a look.</p>\r\n<p>And, by the way, why it is not allowed to upload patched to GreatMaps? :( Can you change this?</p>",
    "PostedDate": "2010-07-15T00:56:12.16-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467676",
    "ThreadId": "219420",
    "Html": "<p>g ;] can you create a fork?</p>\r\n<p>p.s. btw, does it change anything? because i do invalidation using last == true, and is it building for mobile?</p>",
    "PostedDate": "2010-07-15T03:17:05.587-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467684",
    "ThreadId": "219420",
    "Html": "<p>I can, but i don't want to do that :)</p>\r\n<p>The reason is simple - my changes are not fork, it is just a patch.</p>\r\n<p>Please download my patch from the link above and just apply it to your sources.</p>\r\n<p>And it would be very convenient to have &quot;Upload patch&quot; option right here...</p>",
    "PostedDate": "2010-07-15T03:29:06.003-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467685",
    "ThreadId": "219420",
    "Html": "<p>mercurial use forks. effing patches are history ;}</p>",
    "PostedDate": "2010-07-15T03:33:28.16-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467686",
    "ThreadId": "219420",
    "Html": "<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>radioman wrote:</strong><br>\r\n<p>p.s. btw, does it change anything? because i do invalidation using last == true, and is it building for mobile?</p>\r\n</blockquote>\r\n<p>It does. In guarantees that there will be final invalidation (100%).</p>\r\n<p>You can even comment out invalidation inside tile loading thread, and there will be only one invalidation per load/zoom/unzoom. But the tiles will not be shown as they are loading. For some people this kind of behavior can be also interesting.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-07-15T03:33:41.003-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467689",
    "ThreadId": "219420",
    "Html": "<p>i need invalidation each 100ms + one after all tiles loaded to&nbsp;guarantee full view, so whats the difference than using 'bool last' ?</p>",
    "PostedDate": "2010-07-15T03:41:31.43-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "467696",
    "ThreadId": "219420",
    "Html": "<p>1. I've created fork with name &quot;Iljas&quot; and committed my changes.</p>\r\n<p>2. I don't know whether this change is building for mobile platforms as I don't have mobile framework and this project is not building on my machine at all ;)</p>\r\n<p>3. I've tested your changes in the morning and did it once again few minutes ago. There are rare cases when one or several tiles are shown blank (even after disappearing of progress bar)</p>\r\n<p>You can try to reproduce this by doing multiple zoom-unzoom operations. Here is another prooflink (done few minutes ago): http://www.picfront.org/d/7IQU</p>\r\n<p>And the possible reason for such behavior, I think, is simultaneous end of work in several threads.</p>\r\n<p>My solution obtains 100% guarantee for invalidation :)</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-07-15T03:59:14.623-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "468919",
    "ThreadId": "219420",
    "Html": "<p>Hello Radioman!</p>\r\n<p>&nbsp;</p>\r\n<p>I've tested your last commit, it works perfectly!</p>\r\n<p>The only question I have: what was the reason of removing normal thread pool? As far as I know, creation and killing of threads takes some time, and it is possible to avoid overhead by using thread pool (you've used it previously...).</p>",
    "PostedDate": "2010-07-19T02:49:16.31-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "468933",
    "ThreadId": "219420",
    "Html": "<p>threads are created only once, 5 for desktop, 2 for mobile. The desktop version threads has each 5min idle timeout after that thread dies and recreated only when needed, but if you keep 'browsing', they stay as long as needed. I don't know if 5min is really best choice ;}</p>",
    "PostedDate": "2010-07-19T03:26:43.863-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "468940",
    "ThreadId": "219420",
    "Html": "<p>Got your idea, thanks!</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-07-19T03:52:42.21-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]