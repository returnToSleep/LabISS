[
  {
    "Id": "667607",
    "ThreadId": "271481",
    "Html": "\r\n<p>Hello,</p>\r\n<p>I have to determine the external area of some point (markers) that contains all the points.</p>\r\n<p>Sample:</p>\r\n<p>http://imageshack.us/photo/my-images/535/pointsp.png/</p>\r\n<p>http://imageshack.us/photo/my-images/225/areav.png/</p>\r\n<p>Any idea?</p>\r\n<p>(sorry for the synthesis but my english is poor)</p>\r\n<p>&nbsp;</p>\r\n<p>thanx</p>\r\n<p>Franco</p>\r\n",
    "PostedDate": "2011-09-05T00:55:04.297-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "667788",
    "ThreadId": "271481",
    "Html": "<p>well you need to find some algorithm to do that, please share the code if you will</p>\n<p>p.s. check http://greatmaps.codeplex.com/discussions/269680</p>",
    "PostedDate": "2011-09-05T09:48:38.627-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "668515",
    "ThreadId": "271481",
    "Html": "<blockquote style=\"padding-bottom: 0px; font-style: italic; margin: 0.25em 1em 0px; padding-left: 0.25em; padding-right: 0.25em; padding-top: 0px; border: #ccc 0.1em solid;\"><strong>radioman wrote:</strong><br />\r\n<p>well you need to find some algorithm to do that, please share the code if you will</p>\r\n</blockquote>\r\n<p><br />The original code is written in Java (i found it on the internet)</p>\r\n<p>I've translated it and this is the result.</p>\r\n<p>For me it works fine ;)</p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>&nbsp;</pre>\r\n<pre><span style=\"color: blue;\">Imports</span> System.Collections.Generic\r\n<span style=\"color: blue;\">Imports</span> GMap.NET\r\n\r\n<span style=\"color: blue;\">Public</span> <span style=\"color: blue;\">Class</span> Hull\r\n    <span style=\"color: blue;\">Public</span> <span style=\"color: blue;\">Class</span> PositionComparator\r\n        <span style=\"color: blue;\">Implements</span> IComparer(Of PointLatLng)\r\n\r\n        <span style=\"color: blue;\">Public</span> <span style=\"color: blue;\">Function</span> Compare(<span style=\"color: blue;\">ByVal</span> p1 <span style=\"color: blue;\">As</span> GMap.NET.PointLatLng, <span style=\"color: blue;\">ByVal</span> p2 <span style=\"color: blue;\">As</span> GMap.NET.PointLatLng) <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> <span style=\"color: blue;\">Implements</span> System.Collections.Generic.IComparer(Of GMap.NET.PointLatLng).Compare\r\n            <span style=\"color: blue;\">Dim</span> result <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = -2\r\n            <span style=\"color: blue;\">If</span> p1.Lng &gt; p2.Lng <span style=\"color: blue;\">Then</span>\r\n                result = 1\r\n            <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n            <span style=\"color: blue;\">If</span> p1.Lng &lt; p2.Lng <span style=\"color: blue;\">Then</span>\r\n                result = -1\r\n            <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n            <span style=\"color: blue;\">If</span> p1.Lng = p2.Lng <span style=\"color: blue;\">Then</span>\r\n                <span style=\"color: blue;\">If</span> p1.Lat &gt; p2.Lat <span style=\"color: blue;\">Then</span>\r\n                    result = 1\r\n                <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n                <span style=\"color: blue;\">If</span> p1.Lat &lt; p2.Lat <span style=\"color: blue;\">Then</span>\r\n                    result = -1\r\n                <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n                <span style=\"color: blue;\">If</span> p1.Lat = p2.Lat <span style=\"color: blue;\">Then</span>\r\n                    result = 0\r\n                <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n            <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n            <span style=\"color: blue;\">Return</span> result\r\n        <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">Function</span>\r\n    <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">Class</span>\r\n\r\n    <span style=\"color: blue;\">Private</span> <span style=\"color: blue;\">Function</span> isLeft(<span style=\"color: blue;\">ByVal</span> p0 <span style=\"color: blue;\">As</span> PointLatLng, <span style=\"color: blue;\">ByVal</span> p1 <span style=\"color: blue;\">As</span> PointLatLng, <span style=\"color: blue;\">ByVal</span> p2 <span style=\"color: blue;\">As</span> PointLatLng) <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Double</span>\r\n        <span style=\"color: green;\">'isLeft(): tests if a point is Left|On|Right of an infinite line.</span>\r\n        <span style=\"color: green;\">' Input:  three points P0, P1, and P2</span>\r\n        <span style=\"color: green;\">' Return: &gt;0 for P2 left of the line through P0 and P1</span>\r\n        <span style=\"color: green;\">'\t\t   =0 for P2 on the line</span>\r\n        <span style=\"color: green;\">'\t\t   &lt;0 for P2 right of the line</span>\r\n        <span style=\"color: green;\">'function isLeft( P0, P1, P2 ) {</span>\r\n        <span style=\"color: green;\">' return (P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y);</span>\r\n        <span style=\"color: green;\">'}</span>\r\n\r\n        <span style=\"color: blue;\">Return</span> (p1.lng - p0.lng) * (p2.lat - p0.lat) - (p2.lng - p0.lng) * (p1.lat - p0.lat)\r\n    <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">Function</span>\r\n\r\n    <span style=\"color: blue;\">Public</span> <span style=\"color: blue;\">Overridable</span> <span style=\"color: blue;\">Function</span> chainHull_2D(<span style=\"color: blue;\">ByVal</span> p <span style=\"color: blue;\">As</span> List(Of PointLatLng), <span style=\"color: blue;\">ByVal</span> n <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span>, <span style=\"color: blue;\">ByVal</span> h <span style=\"color: blue;\">As</span> List(Of PointLatLng)) <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span>\r\n        <span style=\"color: green;\">'chainHull_2D(): Andrew's monotone chain 2D convex hull algorithm</span>\r\n        <span style=\"color: green;\">'  Input:  P[] = an array of 2D points sorted by increasing x- and y-coordinates</span>\r\n        <span style=\"color: green;\">'\t          n = the number of points in P[]</span>\r\n        <span style=\"color: green;\">'  Output: H[] = an array of the convex hull vertices (max is n)</span>\r\n        <span style=\"color: green;\">'  Return: the number of points in H[]</span>\r\n\r\n        <span style=\"color: green;\">'  Try to order array p</span>\r\n        <span style=\"color: green;\">'Collections.sort(p, New PositionComparator())</span>\r\n        p.Sort(<span style=\"color: blue;\">New</span> PositionComparator())\r\n\r\n        <span style=\"color: green;\">' the output array H[] will be used as the stack</span>\r\n        <span style=\"color: blue;\">Dim</span> bot <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = 0 <span style=\"color: green;\">' indices for bottom of the stack</span>\r\n        <span style=\"color: blue;\">Dim</span> top <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = -1 <span style=\"color: green;\">' indices for top of the stack</span>\r\n        <span style=\"color: blue;\">Dim</span> i <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> <span style=\"color: green;\">' array scan index</span>\r\n\r\n        <span style=\"color: green;\">' Get the indices of points with min x-coord and min|max y-coord</span>\r\n        <span style=\"color: blue;\">Dim</span> minmin <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = 0\r\n        <span style=\"color: blue;\">Dim</span> minmax <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = 0\r\n        <span style=\"color: blue;\">Dim</span> xmin <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Double</span> = p(0).Lng\r\n\r\n        <span style=\"color: blue;\">For</span> i = 1 <span style=\"color: blue;\">To</span> n - 1\r\n            <span style=\"color: blue;\">If</span> p(i).Lng &lt;&gt; xmin <span style=\"color: blue;\">Then</span>\r\n                <span style=\"color: blue;\">Exit</span> <span style=\"color: blue;\">For</span>\r\n            <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n        <span style=\"color: blue;\">Next</span> i\r\n        minmax = i - 1\r\n        <span style=\"color: blue;\">If</span> minmax = n - 1 <span style=\"color: blue;\">Then</span> <span style=\"color: green;\">' degenerate case: all x-coords == xmin</span>\r\n            top += 1\r\n            h.Insert(top, p(minmin))\r\n            <span style=\"color: green;\">'If p(minmax).Lat IsNot p(minmin).Lat Then ' a nontrivial segment</span>\r\n            <span style=\"color: blue;\">If</span> p(minmax).Lat &lt;&gt; p(minmin).Lat <span style=\"color: blue;\">Then</span> <span style=\"color: green;\">' a nontrivial segment</span>\r\n                top += 1\r\n                h.Insert(top, p(minmax))\r\n            <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n            top += 1\r\n            h.Insert(top, p(minmin))\r\n            <span style=\"color: blue;\">Return</span> top + 1\r\n        <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n        <span style=\"color: green;\">' Get the indices of points with max x-coord and min|max y-coord</span>\r\n        <span style=\"color: blue;\">Dim</span> maxmin <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = 0\r\n        <span style=\"color: blue;\">Dim</span> maxmax <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = n - 1\r\n\r\n        <span style=\"color: blue;\">Dim</span> xmax <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Double</span> = p(n - 1).Lng\r\n        <span style=\"color: blue;\">For</span> i = n - 2 <span style=\"color: blue;\">To</span> 0 <span style=\"color: blue;\">Step</span> -1\r\n            <span style=\"color: blue;\">If</span> p(i).Lng &lt;&gt; xmax <span style=\"color: blue;\">Then</span>\r\n                <span style=\"color: blue;\">Exit</span> <span style=\"color: blue;\">For</span>\r\n            <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n        <span style=\"color: blue;\">Next</span> i\r\n        maxmin = i + 1\r\n        <span style=\"color: green;\">' Compute the lower hull on the stack H</span>\r\n        top += 1\r\n        h.Insert(top, p(minmin))\r\n        i = minmax\r\n        i += 1\r\n        <span style=\"color: blue;\">Do</span> <span style=\"color: blue;\">While</span> i &lt;= maxmin\r\n            <span style=\"color: green;\">' the lower line joins P[minmin] with P[maxmin]</span>\r\n            <span style=\"color: blue;\">If</span> (isLeft(p(minmin), p(maxmin), p(i)) &gt;= 0) <span style=\"color: blue;\">AndAlso</span> (i &lt; maxmin) <span style=\"color: blue;\">Then</span>\r\n                i += 1\r\n                <span style=\"color: blue;\">Continue</span> <span style=\"color: blue;\">Do</span> <span style=\"color: green;\">' ignore P[i] above or on the lower line</span>\r\n            <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n\r\n            <span style=\"color: blue;\">Do</span> <span style=\"color: blue;\">While</span> top &gt; 0 <span style=\"color: green;\">' there are at least 2 points on the stack</span>\r\n                <span style=\"color: green;\">' test if P[i] is left of the line at the stack top</span>\r\n                <span style=\"color: blue;\">If</span> isLeft(h(top - 1), h(top), p(i)) &gt; 0 <span style=\"color: blue;\">Then</span>\r\n                    <span style=\"color: blue;\">Exit</span> <span style=\"color: blue;\">Do</span> <span style=\"color: green;\">' P[i] is a new hull vertex</span>\r\n                <span style=\"color: blue;\">Else</span>\r\n                    top -= 1 <span style=\"color: green;\">' pop top point off stack</span>\r\n                <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n            <span style=\"color: blue;\">Loop</span>\r\n            top += 1\r\n            h.Insert(top, p(i))\r\n            i += 1\r\n        <span style=\"color: blue;\">Loop</span>\r\n        <span style=\"color: green;\">' Next, compute the upper hull on the stack H above the bottom hull</span>\r\n        <span style=\"color: blue;\">If</span> maxmax &lt;&gt; maxmin <span style=\"color: blue;\">Then</span> <span style=\"color: green;\">' if distinct xmax points</span>\r\n            top += 1\r\n            h.Insert(top, p(maxmax))\r\n        <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n        bot = top <span style=\"color: green;\">' the bottom point of the upper hull stack</span>\r\n        i = maxmin\r\n        i -= 1\r\n        <span style=\"color: blue;\">Do</span> <span style=\"color: blue;\">While</span> i &gt;= minmax\r\n            <span style=\"color: green;\">' the upper line joins P[maxmax] with P[minmax]</span>\r\n            <span style=\"color: blue;\">If</span> (isLeft(p(maxmax), p(minmax), p(i)) &gt;= 0) <span style=\"color: blue;\">AndAlso</span> (i &gt; minmax) <span style=\"color: blue;\">Then</span>\r\n                i -= 1\r\n                <span style=\"color: blue;\">Continue</span> <span style=\"color: blue;\">Do</span> <span style=\"color: green;\">' ignore P[i] below or on the upper line</span>\r\n            <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n            <span style=\"color: blue;\">Do</span> <span style=\"color: blue;\">While</span> top &gt; bot <span style=\"color: green;\">' at least 2 points on the upper stack</span>\r\n                <span style=\"color: green;\">' test if P[i] is left of the line at the stack top</span>\r\n                <span style=\"color: blue;\">If</span> isLeft(h(top - 1), h(top), p(i)) &gt; 0 <span style=\"color: blue;\">Then</span>\r\n                    <span style=\"color: blue;\">Exit</span> <span style=\"color: blue;\">Do</span> <span style=\"color: green;\">' P[i] is a new hull vertex</span>\r\n                <span style=\"color: blue;\">Else</span>\r\n                    top -= 1 <span style=\"color: green;\">' pop top point off stack</span>\r\n                <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n            <span style=\"color: blue;\">Loop</span>\r\n            top += 1\r\n            h.Insert(top, p(i))\r\n            i -= 1\r\n        <span style=\"color: blue;\">Loop</span>\r\n        <span style=\"color: blue;\">If</span> minmax &lt;&gt; minmin <span style=\"color: blue;\">Then</span>\r\n            top += 1\r\n            h.Insert(top, p(minmin))\r\n        <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">If</span>\r\n        <span style=\"color: blue;\">Dim</span> sizeH <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">Integer</span> = h.<span style=\"color: blue;\">Count</span>\r\n        <span style=\"color: blue;\">For</span> i = top + 1 <span style=\"color: blue;\">To</span> sizeH - 1\r\n            <span style=\"color: green;\">'h.Remove(top + 1)</span>\r\n            h.Remove(h.Item(top + 1))\r\n        <span style=\"color: blue;\">Next</span> i\r\n        <span style=\"color: blue;\">Return</span> top + 1\r\n    <span style=\"color: blue;\">End</span> <span style=\"color: blue;\">Function</span>\r\n<span style=\"color: blue;\">End</span> <span style=\"color: blue;\">Class</span>\r\n</pre>\r\n<pre>&nbsp;</pre>\r\n<pre>Usage:</pre>\r\n<pre>﻿<div style=\"color: black; background-color: white;\"><pre>            <span style=\"color: blue;\">Dim</span> Hull <span style=\"color: blue;\">As</span> <span style=\"color: blue;\">New</span> Hull\r\n            Hull.chainHull_2D(polygonPoints, polygonPoints.<span style=\"color: blue;\">Count</span>, H)\r\n\r\n            <span style=\"color: blue;\">Dim</span> myTestPolygon <span style=\"color: blue;\">As</span> GMapPolygon\r\n            myTestPolygon = <span style=\"color: blue;\">New</span> GMapPolygon(H, <span style=\"color: #a31515;\">\"SquarePolygon\"</span>)\r\n            <span style=\"color: blue;\">Me</span>.Layer_Polygon.Polygons.Add(myTestPolygon)\r\n\r\nPolygonPoints is defined as ﻿﻿﻿﻿New List of PointLatLng</pre>\r\n<pre>Bye and thanks ;)</pre>\r\n<pre>Franco</pre>\r\n</div>\r\n</pre>\r\n</div>",
    "PostedDate": "2011-09-07T03:27:17.743-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "668739",
    "ThreadId": "271481",
    "Html": "<p>Hi:</p>\r\n<p>You propouse an algorithm for discovering if a point is left or right of a line (segment).</p>\r\n<p>I had to do this, and use other code. I want to know (if someone could tell me) wich code is faster</p>\r\n<p>This is your code:</p>\r\n<p>\r\n<pre> Public Function Compare(ByVal p1 As GMap.NET.PointLatLng, ByVal p2 As GMap.NET.PointLatLng) As Integer Implements System.Collections.Generic.IComparer(Of GMap.NET.PointLatLng).Compare\r\n            Dim result As Integer = -2\r\n            If p1.Lng &gt; p2.Lng Then\r\n                result = 1\r\n            End If\r\n            If p1.Lng &lt; p2.Lng Then\r\n                result = -1\r\n            End If\r\n            If p1.Lng = p2.Lng Then\r\n                If p1.Lat &gt; p2.Lat Then\r\n                    result = 1\r\n                End If\r\n                If p1.Lat &lt; p2.Lat Then\r\n                    result = -1\r\n                End If\r\n                If p1.Lat = p2.Lat Then\r\n                    result = 0\r\n                End If\r\n            End If\r\n            Return result\r\n        End Function\r\n    End Class\r\n\r\n    Private Function isLeft(ByVal p0 As PointLatLng, ByVal p1 As PointLatLng, ByVal p2 As PointLatLng) As Double\r\n        'isLeft(): tests if a point is Left|On|Right of an infinite line.\r\n        ' Input:  three points P0, P1, and P2\r\n        ' Return: &gt;0 for P2 left of the line through P0 and P1\r\n        '\t\t   =0 for P2 on the line\r\n        '\t\t   &lt;0 for P2 right of the line\r\n        'function isLeft( P0, P1, P2 ) {\r\n        ' return (P1.x - P0.x)*(P2.y - P0.y) - (P2.x - P0.x)*(P1.y - P0.y);\r\n        '}\r\n\r\n        Return (p1.lng - p0.lng) * (p2.lat - p0.lat) - (p2.lng - p0.lng) * (p1.lat - p0.lat)\r\n    End Function</pre>\r\n</p>\r\n<p>And this is the code i use:</p>\r\n<p>\r\n<pre>bearing_AB = GMapControl1.Manager.GetBearing(pointA, pointB)\r\nbearing_CB = GMapControl1.Manager.GetBearing(puntoC, puntoB)\r\nside = bearing_CB - bearing_AB\r\n                  \r\nif side &gt; 0 then.... (it is on the right)\r\n\r\nIf side &lt; 0 then.... (it is on the left)</pre>\r\n</p>\r\n<p>&nbsp;</p>\r\n<p>Bye</p>\r\n<p>Yeyo</p>",
    "PostedDate": "2011-09-07T11:35:52.53-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "671202",
    "ThreadId": "271481",
    "Html": "<p>Did you get the external area to work ?</p>\r\n<p>Do you know of a method to calculate the actual area selected as Sqr Meters/Kilometers ?</p>",
    "PostedDate": "2011-09-13T07:53:01.977-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]